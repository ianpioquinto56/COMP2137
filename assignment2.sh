#!/bin/bash

# Define constants
NETPLAN_CONFIG="/etc/netplan/01-netcfg.yaml"
TARGET_NET_IP="192.168.16.21"
TARGET_NET_CIDR="24"
TARGET_NET_GW="192.168.16.2"
TARGET_NET_INTERFACE="eth0" # Assuming the non-mgmt interface is eth0, must verify
TARGET_HOSTNAME="server1"

# List of users
USERS=(
    "dennis:sudo"
    "aubrey"
    "captain"
    "snibbles"
    "brownie"
    "scooter"
    "sandy"
    "perrier"
    "cindy"
    "tiger"
    "yoda"
)

# External public key for dennis
DENNIS_EXTERNAL_KEY="ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIG4rT3vTt99Ox5kndS4HmgTrKBT8SKzhK4rhGkEVGlCI student@generic-vm"

# Function for logging success/failure
log() {
    local status=$1
    local message=$2
    if [[ "$status" -eq 0 ]]; then
        echo "‚úÖ SUCCESS: $message"
    else
        echo "‚ùå ERROR: $message (Exit Code: $status)" >&2
    fi
}

# Ensure the script runs as root
if [[ $EUID -ne 0 ]]; then
   log 1 "This script must be run as root. Exiting."
   exit 1
fi

echo "---"
echo "## üöÄ Starting assignment2.sh Configuration Script"
echo "---"

#!/bin/bash

# Define constants
NETPLAN_CONFIG="/etc/netplan/01-netcfg.yaml"
TARGET_NET_IP="192.168.16.21"
TARGET_NET_CIDR="24"
TARGET_NET_GW="192.168.16.2"
TARGET_NET_INTERFACE="eth0" # Assuming the non-mgmt interface is eth0, must verify
TARGET_HOSTNAME="server1"

# List of users
USERS=(
    "dennis:sudo"
    "aubrey"
    "captain"
    "snibbles"
    "brownie"
    "scooter"
    "sandy"
    "perrier"
    "cindy"
    "tiger"
    "yoda"
)

# External public key for dennis
DENNIS_EXTERNAL_KEY="ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIG4rT3vTt99Ox5kndS4HmgTrKBT8SKzhK4rhGkEVGlCI student@generic-vm"

# Function for logging success/failure
log() {
    local status=$1
    local message=$2
    if [[ "$status" -eq 0 ]]; then
        echo "‚úÖ SUCCESS: $message"
    else
        echo "‚ùå ERROR: $message (Exit Code: $status)" >&2
    fi
}

# Ensure the script runs as root
if [[ $EUID -ne 0 ]]; then
   log 1 "This script must be run as root. Exiting."
   exit 1
fi

echo "---"
echo "## üöÄ Starting assignment2.sh Configuration Script"
echo "---"

echo "### üåê Netplan Configuration for $TARGET_NET_INTERFACE"
# We must ensure the correct network configuration is present and static.
# We will use a heredoc to overwrite the file contents, assuming the configuration 
# is for the interface connected to the 192.168.16.x network (non-mgmt).

# Check if the IP is already present in the file
if grep -q "$TARGET_NET_IP" "$NETPLAN_CONFIG"; then
    log 0 "Netplan already configured with $TARGET_NET_IP. No change needed."
else
    # This assumes a standard netplan file structure and overwrites it for idempotency
    cat <<EOF > "$NETPLAN_CONFIG"
# This file is generated by assignment2.sh
network:
  version: 2
  renderer: networkd
  ethernets:
    $TARGET_NET_INTERFACE:
      dhcp4: no
      addresses: [$TARGET_NET_IP/$TARGET_NET_CIDR]
      routes:
        - to: default
          via: $TARGET_NET_GW
EOF
    if [[ $? -eq 0 ]]; then
        log 0 "Updated $NETPLAN_CONFIG with static IP $TARGET_NET_IP."
        
        # Apply the netplan configuration
        echo "Applying netplan configuration..."
        netplan apply
        if [[ $? -eq 0 ]]; then
            log 0 "Netplan applied successfully."
        else
            log $? "Failed to apply netplan configuration. Check syntax."
        fi
    else
        log $? "Failed to write new netplan configuration to $NETPLAN_CONFIG."
    fi
fi

echo "---"

echo "### üìú /etc/hosts Configuration"

HOSTS_FILE="/etc/hosts"
NEW_HOSTS_ENTRY="$TARGET_NET_IP\t$TARGET_HOSTNAME"

# 1. Check if the correct entry is present
if grep -q "^$NEW_HOSTS_ENTRY" "$HOSTS_FILE"; then
    log 0 "Correct $TARGET_HOSTNAME entry already exists in $HOSTS_FILE. No changes needed."
else
    # 2. Remove any old or incorrect entries for server1
    # Deletes lines that contain 'server1' but DO NOT start with the correct IP
    sed -i "/$TARGET_HOSTNAME/!b;/^$TARGET_NET_IP/d" "$HOSTS_FILE"
    
    # Check if the desired line was removed or if sed failed
    if [[ $? -ne 0 ]]; then
        log $? "Error during initial removal/check phase of /etc/hosts."
    fi

    # 3. Add the new entry to /etc/hosts
    if ! grep -q "^$NEW_HOSTS_ENTRY" "$HOSTS_FILE"; then
        echo -e "$NEW_HOSTS_ENTRY" >> "$HOSTS_FILE"
        if [[ $? -eq 0 ]]; then
            log 0 "Updated $HOSTS_FILE: Added $NEW_HOSTS_ENTRY and removed old entries."
        else
            log $? "Failed to append $NEW_HOSTS_ENTRY to $HOSTS_FILE."
        fi
    else
        log 0 "Correct $TARGET_HOSTNAME entry is present, confirming old entries removed."
    fi
fi

echo "---"

echo "### üì¶ Software Installation and Service Status"

PACKAGES=("apache2" "squid")

for PKG in "${PACKAGES[@]}"; do
    if dpkg-query -W "$PKG" >/dev/null 2>&1; then
        log 0 "$PKG is already installed."
    else
        echo "Installing $PKG..."
        DEBIAN_FRONTEND=noninteractive apt-get update >/dev/null && apt-get install -y "$PKG"
        if [[ $? -eq 0 ]]; then
            log 0 "$PKG installed successfully."
        else
            log $? "Failed to install $PKG."
            continue # Skip service check if install failed
        fi
    fi

    # Check and start/enable service
    if systemctl is-active --quiet "$PKG"; then
        log 0 "$PKG service is active and running."
    else
        echo "Starting and enabling $PKG service..."
        systemctl enable --now "$PKG"
        if [[ $? -eq 0 ]]; then
            log 0 "$PKG service enabled and started."
        else
            log $? "Failed to start and enable $PKG service."
        fi
    fi
done

echo "---"

echo "### üßë‚Äçüíª User Account Configuration"

for USER_ENTRY in "${USERS[@]}"; do
    USERNAME=$(echo "$USER_ENTRY" | cut -d: -f1)
    GROUP_MOD=$(echo "$USER_ENTRY" | cut -d: -f2)
    
    echo "Processing user: $USERNAME"

    # 1. Check and Create User
    if id -u "$USERNAME" >/dev/null 2>&1; then
        log 0 "User $USERNAME already exists."
    else
        useradd -m -s /bin/bash "$USERNAME"
        if [[ $? -eq 0 ]]; then
            log 0 "Created user $USERNAME with home directory and /bin/bash shell."
        else
            log $? "Failed to create user $USERNAME."
            continue
        fi
    fi

    USER_HOME="/home/$USERNAME"
    SSH_DIR="$USER_HOME/.ssh"
    AUTH_KEYS="$SSH_DIR/authorized_keys"

    # Ensure .ssh directory exists and has correct permissions
    if [[ ! -d "$SSH_DIR" ]]; then
        mkdir -p "$SSH_DIR" && chown "$USERNAME:$USERNAME" "$SSH_DIR" && chmod 700 "$SSH_DIR"
        if [[ $? -eq 0 ]]; then
            log 0 "Created .ssh directory for $USERNAME."
        else
            log $? "Failed to create .ssh directory for $USERNAME."
        fi
    fi
    
    # 2. Handle Sudo Access (for dennis)
    if [[ "$GROUP_MOD" == "sudo" ]]; then
        if id -nG "$USERNAME" | grep -qw "sudo"; then
            log 0 "$USERNAME is already a member of the sudo group."
        else
            usermod -aG sudo "$USERNAME"
            if [[ $? -eq 0 ]]; then
                log 0 "Added $USERNAME to the sudo group."
            else
                log $? "Failed to add $USERNAME to the sudo group."
            fi
        fi
    fi

    # 3. Generate SSH Keys (RSA and ED25519) and configure authorized_keys
    for KEY_TYPE in rsa ed25519; do
        KEY_FILE="$SSH_DIR/id_$KEY_TYPE"
        PUB_KEY_FILE="$KEY_FILE.pub"
        
        if [[ ! -f "$PUB_KEY_FILE" ]]; then
            # Generate key pairs, no passphrase (-N '')
            ssh-keygen -t "$KEY_TYPE" -N "" -f "$KEY_FILE" >/dev/null 2>&1
            chown "$USERNAME:$USERNAME" "$KEY_FILE"*
            chmod 600 "$KEY_FILE"
            if [[ $? -eq 0 ]]; then
                log 0 "Generated $KEY_TYPE SSH keys for $USERNAME."
            else
                log $? "Failed to generate $KEY_TYPE SSH keys for $USERNAME."
            fi
        else
            log 0 "$KEY_TYPE SSH key already exists for $USERNAME."
        fi

        # Add the generated public key to authorized_keys if not present
        if [[ -f "$PUB_KEY_FILE" ]]; then
            GENERATED_KEY=$(cat "$PUB_KEY_FILE")
            if ! grep -qF "$GENERATED_KEY" "$AUTH_KEYS"; then
                echo "$GENERATED_KEY" >> "$AUTH_KEYS"
                log 0 "Added generated $KEY_TYPE public key to $AUTH_KEYS for $USERNAME."
            else
                log 0 "Generated $KEY_TYPE public key is already in $AUTH_KEYS for $USERNAME."
            fi
        fi
    done
    
    # 4. Handle Dennis's External Key
    if [[ "$USERNAME" == "dennis" ]]; then
        if ! grep -qF "$DENNIS_EXTERNAL_KEY" "$AUTH_KEYS"; then
            echo "$DENNIS_EXTERNAL_KEY" >> "$AUTH_KEYS"
            log 0 "Added external ED25519 public key for dennis to $AUTH_KEYS."
        else
            log 0 "External ED25519 public key is already in $AUTH_KEYS for dennis."
        fi
    fi
    
    # Final permissions check on authorized_keys
    chown "$USERNAME:$USERNAME" "$AUTH_KEYS"
    chmod 600 "$AUTH_KEYS"
    log 0 "Set final permissions for $AUTH_KEYS."
    echo "" # Newline for readability
done

echo "---"
echo "## ‚úÖ Configuration Complete"
echo "---"
