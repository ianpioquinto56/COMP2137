#!/bin/bash

# Define constants
NETPLAN_CONFIG="/etc/netplan/01-netcfg.yaml"
TARGET_NET_IP="192.168.16.21"
TARGET_NET_CIDR="24"
TARGET_NET_GW="192.168.16.2"
TARGET_NET_INTERFACE="eth0"
TARGET_HOSTNAME="server1"

# List of users
USERS=(
    "dennis:sudo"
    "aubrey"
    "captain"
    "snibbles"
    "brownie"
    "scooter"
    "sandy"
    "perrier"
    "cindy"
    "tiger"
    "yoda"
)

# External public key for dennis
DENNIS_EXTERNAL_KEY="ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIG4rT3vTt99Ox5kndS4HmgTrKBT8SKzhK4rhGkEVGlCI student@generic-vm"

# Function for logging success/failure
log() {
    local status=$1
    local message=$2
    if [[ "$status" -eq 0 ]]; then
        echo "âœ… SUCCESS: $message"
    else
        echo "âŒ ERROR: $message (Exit Code: $status)" >&2
    fi
}

# --- Initialization and Root Check ---
if [[ $EUID -ne 0 ]]; then
   log 1 "This script must be run as root. Exiting."
   exit 1
fi

echo "---"
echo "## ðŸš€ Starting assignment2.sh Configuration Script"
echo "---"

# --- 1. Netplan Configuration (Set 192.168.16.21/24 and Remove all others) ---
echo "### ðŸŒ Netplan Configuration for $TARGET_NET_INTERFACE"

# Explicitly remove unwanted IP addresses from the interface if they are currently active.
UNWANTED_IPS=("192.168.16.241" "192.168.16.242")
for IP_TO_REMOVE in "${UNWANTED_IPS[@]}"; do
    if ip a show dev "$TARGET_NET_INTERFACE" | grep -q "$IP_TO_REMOVE"; then
        echo "Attempting to remove unwanted IP $IP_TO_REMOVE from $TARGET_NET_INTERFACE..."
        ip addr del "$IP_TO_REMOVE/$TARGET_NET_CIDR" dev "$TARGET_NET_INTERFACE" 2>/dev/null
        if [[ $? -eq 0 ]]; then
            log 0 "Successfully removed active unwanted IP $IP_TO_REMOVE."
        else
            log $? "Failed to remove active unwanted IP $IP_TO_REMOVE."
        fi
    else
        log 0 "Unwanted IP $IP_TO_REMOVE is not currently active on $TARGET_NET_INTERFACE."
    fi
done

# Check if the desired configuration is already defined in the Netplan file.
NETPLAN_FILE_MODIFIED=0
if grep -E "^\s*addresses:\s*\[$TARGET_NET_IP/$TARGET_NET_CIDR\]" "$NETPLAN_CONFIG" >/dev/null 2>&1; then
    log 0 "Netplan configuration file already defines $TARGET_NET_IP."
else
    # Overwrite the netplan configuration for the target interface.
    cat <<EOF > "$NETPLAN_CONFIG"
# This file is generated by assignment2.sh to configure $TARGET_NET_INTERFACE
network:
  version: 2
  renderer: networkd
  ethernets:
    $TARGET_NET_INTERFACE:
      dhcp4: no
      addresses: [$TARGET_NET_IP/$TARGET_NET_CIDR]
      routes:
        - to: default
          via: $TARGET_NET_GW
EOF
    if [[ $? -eq 0 ]]; then
        log 0 "Updated $NETPLAN_CONFIG with static IP $TARGET_NET_IP."
        NETPLAN_FILE_MODIFIED=1
    else
        log $? "Failed to write new netplan configuration to $NETPLAN_CONFIG."
    fi
fi

# --- FIX: Set secure permissions (rw-------) to suppress the Netplan warning ---
if [[ "$NETPLAN_FILE_MODIFIED" -eq 1 ]] || [[ $(stat -c "%a" "$NETPLAN_CONFIG") != "600" ]]; then
    chmod 600 "$NETPLAN_CONFIG"
    if [[ $? -eq 0 ]]; then
        log 0 "Set secure permissions (600) on $NETPLAN_CONFIG."
    else
        log $? "Failed to set permissions on $NETPLAN_CONFIG."
    fi
fi
# ------------------------------------------------------------------------------

# Apply the netplan configuration only if needed.
CURRENT_IP=$(ip a show dev "$TARGET_NET_INTERFACE" | grep -oP 'inet \K[\d\.]+/[\d]+' | grep "^$TARGET_NET_IP")

if [[ "$NETPLAN_FILE_MODIFIED" -eq 1 ]] || [[ -z "$CURRENT_IP" ]]; then
    echo "Applying netplan configuration..."
    netplan apply
    if [[ $? -eq 0 ]]; then
        log 0 "Netplan applied successfully. Interface should now be $TARGET_NET_IP."
    else
        log $? "Failed to apply netplan configuration. Check configuration and network state."
    fi
else
    log 0 "Netplan configuration already matches desired state. Skipping 'netplan apply'."
fi

echo "---"

# --- 2. Update /etc/hosts ---
echo "### ðŸ“œ /etc/hosts Configuration"

HOSTS_FILE="/etc/hosts"
NEW_HOSTS_ENTRY="$TARGET_NET_IP\t$TARGET_HOSTNAME"

# Remove all existing entries for TARGET_HOSTNAME that do not match the new IP
sed -i "/$TARGET_HOSTNAME/!b;/^$TARGET_NET_IP/d" "$HOSTS_FILE"
HOSTS_RC=$?

# Check if the correct entry is present; if not, add it
if ! grep -q "^$NEW_HOSTS_ENTRY" "$HOSTS_FILE"; then
    echo -e "$NEW_HOSTS_ENTRY" >> "$HOSTS_FILE"
    if [[ $? -eq 0 ]]; then
        log 0 "Updated $HOSTS_FILE: Added $NEW_HOSTS_ENTRY and removed old entries."
    else
        log $? "Failed to append $NEW_HOSTS_ENTRY to $HOSTS_FILE."
    fi
elif [[ $HOSTS_RC -eq 0 ]]; then
    log 0 "Correct $TARGET_HOSTNAME entry is present and old entries were removed."
else
    log 0 "Correct $TARGET_HOSTNAME entry is present."
fi

echo "---"

# --- 3. Install and Ensure Software is Running ---
echo "### ðŸ“¦ Software Installation and Service Status"

PACKAGES=("apache2" "squid")

# Update package lists only once
apt-get update >/dev/null 2>&1

for PKG in "${PACKAGES[@]}"; do
    if dpkg-query -W "$PKG" >/dev/null 2>&1; then
        log 0 "$PKG is already installed."
    else
        echo "Installing $PKG..."
        DEBIAN_FRONTEND=noninteractive apt-get install -y "$PKG" >/dev/null 2>&1
        if [[ $? -eq 0 ]]; then
            log 0 "$PKG installed successfully."
        else
            log $? "Failed to install $PKG."
            continue
        fi
    fi

    # Check and start/enable service
    if systemctl is-active --quiet "$PKG"; then
        log 0 "$PKG service is active and running."
    else
        echo "Starting and enabling $PKG service..."
        systemctl enable --now "$PKG" >/dev/null 2>&1
        if [[ $? -eq 0 ]]; then
            log 0 "$PKG service enabled and started."
        else
            log $? "Failed to start and enable $PKG service."
        fi
    fi
done

echo "---"

# --- 4. Create and Configure User Accounts ---
echo "### ðŸ§‘â€ðŸ’» User Account Configuration"

# Set up /etc/skel for new users
SKEL_SSH_DIR="/etc/skel/.ssh"
SKEL_AUTH_KEYS="$SKEL_SSH_DIR/authorized_keys"

if [[ ! -d "$SKEL_SSH_DIR" ]]; then
    mkdir -p "$SKEL_SSH_DIR"
    log 0 "Created .ssh directory in /etc/skel."
fi
# Ensure the authorized_keys file exists and has correct permissions for automatic copy
touch "$SKEL_AUTH_KEYS"
chmod 600 "$SKEL_AUTH_KEYS"
chmod 700 "$SKEL_SSH_DIR"
log 0 "Configured /etc/skel/.ssh/authorized_keys for new users."


for USER_ENTRY in "${USERS[@]}"; do
    USERNAME=$(echo "$USER_ENTRY" | cut -d: -f1)
    GROUP_MOD=$(echo "$USER_ENTRY" | cut -d: -f2)
    
    echo "Processing user: $USERNAME"

    USER_HOME="/home/$USERNAME"
    SSH_DIR="$USER_HOME/.ssh"
    AUTH_KEYS="$SSH_DIR/authorized_keys"

    # A. Check and Create User
    if id -u "$USERNAME" >/dev/null 2>&1; then
        log 0 "User $USERNAME already exists."
    else
        # useradd -m copies from /etc/skel
        useradd -m -s /bin/bash "$USERNAME"
        if [[ $? -eq 0 ]]; then
            log 0 "Created user $USERNAME with home directory and /bin/bash shell using /etc/skel."
        else
            log $? "Failed to create user $USERNAME."
            continue
        fi
    fi
    
    # Ensure .ssh structure exists for pre-existing users or for safety
    if [[ ! -d "$SSH_DIR" ]]; then
        mkdir -p "$SSH_DIR"
        touch "$AUTH_KEYS"
        chown "$USERNAME:$USERNAME" "$SSH_DIR" "$AUTH_KEYS"
        chmod 700 "$SSH_DIR"
        chmod 600 "$AUTH_KEYS"
        log 0 "Initialized .ssh structure for existing user $USERNAME."
    fi

    # B. Handle Sudo Access
    if [[ "$GROUP_MOD" == "sudo" ]]; then
        if id -nG "$USERNAME" | grep -qw "sudo"; then
            log 0 "$USERNAME is already a member of the sudo group."
        else
            usermod -aG sudo "$USERNAME"
            if [[ $? -eq 0 ]]; then
                log 0 "Added $USERNAME to the sudo group."
            else
                log $? "Failed to add $USERNAME to the sudo group."
            fi
        fi
    fi

    # C. Generate SSH Keys (RSA and ED25519) and copy to authorized_keys
    for KEY_TYPE in rsa ed25519; do
        KEY_FILE="$SSH_DIR/id_$KEY_TYPE"
        PUB_KEY_FILE="$KEY_FILE.pub"
        
        # 1. Generate Key Pair
        if [[ ! -f "$PUB_KEY_FILE" ]]; then
            # Generate key pairs, no passphrase (-N '')
            ssh-keygen -t "$KEY_TYPE" -N "" -f "$KEY_FILE" >/dev/null 2>&1
            if [[ $? -eq 0 ]]; then
                log 0 "Generated $KEY_TYPE SSH keys for $USERNAME."
            else
                log $? "Failed to generate $KEY_TYPE SSH keys for $USERNAME."
                continue
            fi
        else
            log 0 "$KEY_TYPE SSH key already exists for $USERNAME."
        fi

        # 2. Add generated public key to authorized_keys (required step)
        GENERATED_KEY=$(cat "$PUB_KEY_FILE" 2>/dev/null)
        if [[ -n "$GENERATED_KEY" ]] && ! grep -qF "$GENERATED_KEY" "$AUTH_KEYS"; then
            echo "$GENERATED_KEY" >> "$AUTH_KEYS"
            log 0 "Copied generated $KEY_TYPE public key to $AUTH_KEYS."
        else
            log 0 "Generated $KEY_TYPE public key is already in $AUTH_KEYS or file not found."
        fi
    done
    
    # D. Handle Dennis's External Key
    if [[ "$USERNAME" == "dennis" ]]; then
        if ! grep -qF "$DENNIS_EXTERNAL_KEY" "$AUTH_KEYS"; then
            echo "$DENNIS_EXTERNAL_KEY" >> "$AUTH_KEYS"
            log 0 "Added external ED25519 public key for dennis to $AUTH_KEYS."
        else
            log 0 "External ED25519 public key is already in $AUTH_KEYS for dennis."
        fi
    fi
    
    # E. Final permissions and ownership after key generation (created by root)
    chown -R "$USERNAME:$USERNAME" "$SSH_DIR" 2>/dev/null
    chmod 600 "$AUTH_KEYS" 2>/dev/null
    log 0 "Set final ownership/permissions for $SSH_DIR and keys for $USERNAME."
    echo "" # Newline for readability
done

echo "---"
echo "## âœ… Configuration Complete"
echo "---"
